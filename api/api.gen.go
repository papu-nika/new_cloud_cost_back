// Package api provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.4.1 DO NOT EDIT.
package api

import (
	"bytes"
	"compress/gzip"
	"context"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"

	"github.com/getkin/kin-openapi/openapi3"
	"github.com/gin-gonic/gin"
	"github.com/oapi-codegen/runtime"
	strictgin "github.com/oapi-codegen/runtime/strictmiddleware/gin"
)

const (
	BearerAuthScopes = "BearerAuth.Scopes"
)

// Defines values for RegionEnum.
const (
	AfSouth1     RegionEnum = "af-south-1"
	ApEast1      RegionEnum = "ap-east-1"
	ApNortheast1 RegionEnum = "ap-northeast-1"
	ApNortheast2 RegionEnum = "ap-northeast-2"
	ApNortheast3 RegionEnum = "ap-northeast-3"
	ApSouth1     RegionEnum = "ap-south-1"
	ApSouth2     RegionEnum = "ap-south-2"
	ApSoutheast1 RegionEnum = "ap-southeast-1"
	ApSoutheast2 RegionEnum = "ap-southeast-2"
	ApSoutheast3 RegionEnum = "ap-southeast-3"
	ApSoutheast4 RegionEnum = "ap-southeast-4"
	CaCentral1   RegionEnum = "ca-central-1"
	CaWest1      RegionEnum = "ca-west-1"
	EuCentral1   RegionEnum = "eu-central-1"
	EuCentral2   RegionEnum = "eu-central-2"
	EuNorth1     RegionEnum = "eu-north-1"
	EuSouth1     RegionEnum = "eu-south-1"
	EuSouth2     RegionEnum = "eu-south-2"
	EuWest1      RegionEnum = "eu-west-1"
	EuWest2      RegionEnum = "eu-west-2"
	EuWest3      RegionEnum = "eu-west-3"
	IlCentral1   RegionEnum = "il-central-1"
	MeCentral1   RegionEnum = "me-central-1"
	MeSouth1     RegionEnum = "me-south-1"
	SaEast1      RegionEnum = "sa-east-1"
	UsEast1      RegionEnum = "us-east-1"
	UsEast2      RegionEnum = "us-east-2"
	UsGovEast1   RegionEnum = "us-gov-east-1"
	UsGovWest1   RegionEnum = "us-gov-west-1"
	UsWest1      RegionEnum = "us-west-1"
	UsWest2      RegionEnum = "us-west-2"
)

// Defines values for OsEnum.
const (
	Linux     OsEnum = "linux"
	Rhel      OsEnum = "rhel"
	UbuntuPro OsEnum = "ubuntu-pro"
	Windows   OsEnum = "windows"
)

// Region defines model for Region.
type Region struct {
	Region RegionEnum `json:"region" validate:"oneof=ap-south-1 ap-south-2 ap-northeast-1 ap-northeast-2 ap-northeast-3 ap-southeast-1 ap-southeast-2 ap-southeast-3 ap-southeast-4 ap-east-1 us-east-1 us-east-2 us-west-1 us-west-2 ca-central-1 ca-west-1 us-gov-east-1 us-gov-west-1 sa-east-1 eu-west-1 eu-west-2 eu-west-3 eu-central-1 eu-central-2 eu-north-1 eu-south-1 eu-south-2 il-central-1 af-south-1 me-central-1 me-south-1"`
}

// RegionEnum defines model for RegionEnum.
type RegionEnum string

// Os defines model for os.
type Os struct {
	Os OsEnum `json:"os" validate:"oneof=linux windows ubuntu-pro rhel"`
}

// OsEnum defines model for osEnum.
type OsEnum string

// GetAwsEc2InstancesParams defines parameters for GetAwsEc2Instances.
type GetAwsEc2InstancesParams struct {
	// Region Filter instance by region
	Region *Region `form:"region,omitempty" json:"region,omitempty"`

	// Os Filter instance by name
	Os *Os `form:"os,omitempty" json:"os,omitempty"`
}

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get EC2 instances cost with optional filtering
	// (GET /aws/ec2/instances)
	GetAwsEc2Instances(c *gin.Context, params GetAwsEc2InstancesParams)
}

// ServerInterfaceWrapper converts contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler            ServerInterface
	HandlerMiddlewares []MiddlewareFunc
	ErrorHandler       func(*gin.Context, error, int)
}

type MiddlewareFunc func(c *gin.Context)

// GetAwsEc2Instances operation middleware
func (siw *ServerInterfaceWrapper) GetAwsEc2Instances(c *gin.Context) {

	var err error

	c.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetAwsEc2InstancesParams

	// ------------- Optional query parameter "region" -------------

	err = runtime.BindQueryParameter("form", true, false, "region", c.Request.URL.Query(), &params.Region)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter region: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "os" -------------

	err = runtime.BindQueryParameter("form", true, false, "os", c.Request.URL.Query(), &params.Os)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter os: %w", err), http.StatusBadRequest)
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.GetAwsEc2Instances(c, params)
}

// GinServerOptions provides options for the Gin server.
type GinServerOptions struct {
	BaseURL      string
	Middlewares  []MiddlewareFunc
	ErrorHandler func(*gin.Context, error, int)
}

// RegisterHandlers creates http.Handler with routing matching OpenAPI spec.
func RegisterHandlers(router gin.IRouter, si ServerInterface) {
	RegisterHandlersWithOptions(router, si, GinServerOptions{})
}

// RegisterHandlersWithOptions creates http.Handler with additional options
func RegisterHandlersWithOptions(router gin.IRouter, si ServerInterface, options GinServerOptions) {
	errorHandler := options.ErrorHandler
	if errorHandler == nil {
		errorHandler = func(c *gin.Context, err error, statusCode int) {
			c.JSON(statusCode, gin.H{"msg": err.Error()})
		}
	}

	wrapper := ServerInterfaceWrapper{
		Handler:            si,
		HandlerMiddlewares: options.Middlewares,
		ErrorHandler:       errorHandler,
	}

	router.GET(options.BaseURL+"/aws/ec2/instances", wrapper.GetAwsEc2Instances)
}

type GetAwsEc2InstancesRequestObject struct {
	Params GetAwsEc2InstancesParams
}

type GetAwsEc2InstancesResponseObject interface {
	VisitGetAwsEc2InstancesResponse(w http.ResponseWriter) error
}

type GetAwsEc2Instances200JSONResponse []struct {
	Clockspeed                        *string  `json:"clockspeed,omitempty"`
	Dedicatedebsthroughput            *string  `json:"dedicatedebsthroughput,omitempty"`
	Ecu                               *string  `json:"ecu,omitempty"`
	Gpumemory                         *string  `json:"gpumemory,omitempty"`
	Id                                *string  `json:"id,omitempty"`
	Instancefamily                    *string  `json:"instancefamily,omitempty"`
	Instancetype                      *string  `json:"instancetype,omitempty"`
	Memory                            *float32 `json:"memory,omitempty"`
	Networkperformance                *string  `json:"networkperformance,omitempty"`
	Ondemandprice                     *float32 `json:"ondemandprice,omitempty"`
	OneYearReservedConvertiblePrice   *float32 `json:"one_year_reserved_convertible_price,omitempty"`
	OneYearReservedStandardPrice      *float32 `json:"one_year_reserved_standard_price,omitempty"`
	Operatingsystem                   *string  `json:"operatingsystem,omitempty"`
	Physicalprocessor                 *string  `json:"physicalprocessor,omitempty"`
	Processorfeatures                 *string  `json:"processorfeatures,omitempty"`
	Regioncode                        *string  `json:"regioncode,omitempty"`
	Storage                           *string  `json:"storage,omitempty"`
	Tenancy                           *string  `json:"tenancy,omitempty"`
	ThreeYearReservedConvertiblePrice *float32 `json:"three_year_reserved_convertible_price,omitempty"`
	ThreeYearReservedStandardPrice    *float32 `json:"three_year_reserved_standard_price,omitempty"`
	Vcpu                              *float32 `json:"vcpu,omitempty"`
}

func (response GetAwsEc2Instances200JSONResponse) VisitGetAwsEc2InstancesResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type GetAwsEc2Instances400Response struct {
}

func (response GetAwsEc2Instances400Response) VisitGetAwsEc2InstancesResponse(w http.ResponseWriter) error {
	w.WriteHeader(400)
	return nil
}

// StrictServerInterface represents all server handlers.
type StrictServerInterface interface {
	// Get EC2 instances cost with optional filtering
	// (GET /aws/ec2/instances)
	GetAwsEc2Instances(ctx context.Context, request GetAwsEc2InstancesRequestObject) (GetAwsEc2InstancesResponseObject, error)
}

type StrictHandlerFunc = strictgin.StrictGinHandlerFunc
type StrictMiddlewareFunc = strictgin.StrictGinMiddlewareFunc

func NewStrictHandler(ssi StrictServerInterface, middlewares []StrictMiddlewareFunc) ServerInterface {
	return &strictHandler{ssi: ssi, middlewares: middlewares}
}

type strictHandler struct {
	ssi         StrictServerInterface
	middlewares []StrictMiddlewareFunc
}

// GetAwsEc2Instances operation middleware
func (sh *strictHandler) GetAwsEc2Instances(ctx *gin.Context, params GetAwsEc2InstancesParams) {
	var request GetAwsEc2InstancesRequestObject

	request.Params = params

	handler := func(ctx *gin.Context, request interface{}) (interface{}, error) {
		return sh.ssi.GetAwsEc2Instances(ctx, request.(GetAwsEc2InstancesRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "GetAwsEc2Instances")
	}

	response, err := handler(ctx, request)

	if err != nil {
		ctx.Error(err)
		ctx.Status(http.StatusInternalServerError)
	} else if validResponse, ok := response.(GetAwsEc2InstancesResponseObject); ok {
		if err := validResponse.VisitGetAwsEc2InstancesResponse(ctx.Writer); err != nil {
			ctx.Error(err)
		}
	} else if response != nil {
		ctx.Error(fmt.Errorf("unexpected response type: %T", response))
	}
}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"H4sIAAAAAAAC/6RVzW7jNhB+FYLtUbazSk4CekiDbJGiBRZtgR6CIKCpscSNxOEOh3bcwO9ekLL1YwtB",
	"2j15/seaj9/Mm9TYOrRg2cviTXpdQ6uS+AdUBm2UHKEDYgPJTr39R4KNLOQPq6HG6lhg1WXf29DKwyGT",
	"BN+CIShl8Xgq8JRJ3juQhcT1V9AsD5kcZRVvEtLvo1Ru4TFwvfgks0HJO8UicQ3K88k7GC4irkf545TB",
	"kJ8bLlJuOkOfHvylnHfyDgZ7kqNdq4UGy6Sa5NJqElbhdlIu6r3fq8EHYbCf5HwkX3fyuNVIPUamyZx8",
	"w4h7JYaZZlJEbUaBLUx8LfS+AVzPZGwlM/m6QOXMQmMJFdgFvDKpBasqPaqtakypOL0GC7j5acBcDIiL",
	"Kd5T9cx7LaZIT9V8qp4F34geYdHj20u56LHtpVyMcRU9qmKCqZggKno8RY9mL+W9dC3GOI6VFHPEUAwI",
	"DmIuxuiJATsxRk6McItcRX9J+s72HuHRz5Id/SzRj9EjkjfGhleZyZ2xJe58fP7rYDksHKHMJNXQfP+r",
	"Sk3EsYUYGohU/hD/vAcdyPD+z/hd3cf/DIqAbgPXUVsn7TNSq1gW8te//4rUTNGyOHpl/0drZtcVNnaD",
	"Mb8Er8k4TktU3n55EBsk0SqrKmMroRsMpdDo2WeCSemXaA1eVZAJZUuBVClr/olWD7Q1GrwwllE4wjhe",
	"v4zdDTex/V2qdoeexe+xA7RgWdx+eZCZ3AL57k98Wl4trxIsDqxyRhbyenm1jDvEKa7TEFZq51eg85Wx",
	"npXV3Wgq4PQ8HJCKX/RQykL+Any78/c6f+hDYyFSLTCQl8Xj+RQ+m4aBxKm0WO/F8UrEuclCfgtAe5lJ",
	"q9KUe2f3+j52jOLb/EDj1GK+LfoPt0QvD4enyAXv0PpuWvnVVfzRaBlsGpxyrjE6jW711XdndWhgGNoZ",
	"MuoG9Yt3EBn2dsaIQyZLKGNJKGHtuSYMVe0Cz4aCDrP2yoUWWqT9rNfM9z0NcaNa0+zfDekcMwEXXW1o",
	"10DRZYF3SC8OaBO5Z/V8BbQltMqWjswkYiiEFp73oOiZIBIIymeNdhvHu27g+b/kxY8pFZXvJXXMsJXf",
	"e4Z29i+7eu+NVo0j1OA90nzUybsBxYG6p3AR1TEjrsNZt2ckVc37GKyyeh44rgn+39TmMj8wt612YcZx",
	"mLklR4MiUvtu1U45/pvxLHDTkzzm3HRMnAY+2HQwhLGRL+kYhLZV8T3GnSbu7/K+iE8rWuwM1wJTAdWI",
	"TdomaWTjU5IW3viIPD7F1ZCGcVyHgZrjsfDFaqWcWaY7sIhNlhpbeXg6/BsAAP//yGMYqKwLAAA=",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
